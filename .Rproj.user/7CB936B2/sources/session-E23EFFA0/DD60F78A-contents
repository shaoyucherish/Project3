---
title: "ST558 - Project 2"
author: "Li Wang & Bryan Bittner"
date: "`r Sys.Date()`"
output: 
  github_document: default
   
  html_document:
    code_folding: hide
    
params:
    columnNames: ""
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```


```{r,eval=FALSE}
rmarkdown::render("Project2.Rmd", 
                  output_format = "github_document",
                  output_file = "README.md",
                  output_options = list(html_preview= FALSE,toc=TRUE,toc_depth=2,toc_float=TRUE)
)
```


# Load Packages

We will use the following packages:

```{r}
library(rmarkdown)
library(httr)
library(jsonlite)
library(readr)
library(tidyverse)
library(lubridate)
library(knitr)
library(caret)
library(randomForest)
library(corrplot)
library(gbm)
```


# Introduction

This [online News Popularity Data Set](https://archive.ics.uci.edu/ml/datasets/Online+News+Popularity) summarizes a heterogeneous set of features about articles published by Mashable in a period of two years.

Our target variable is the shares variable(Number of shares ), and predict variables are the following:

+ publishing_day: Day of the article published
+ n_tokens_title: Number of words in the title
+ n_tokens_content: Number of words in the content
+ num_self_hrefs: Number of links to other articles published by Mashable
+ num_imgs: Number of images
+ num_videos:  Number of videos
+ average_token_length: Average length of the words in the content
+ num_keywords: Number of keywords in the metadata
+ kw_avg_min: Worst keyword (avg. shares)
+ kw_avg_avg: Avg. keyword (avg. shares)
+ self_reference_avg_shares: Avg. shares of referenced articles in Mashable
+ LDA_04: Closeness to LDA topic 4
+ global_subjectivity: ext subjectivity
+ global_rate_positive_words: Rate of positive words in the content
+ rate_positive_words: Rate of positive words among non-neutral tokens
+ avg_positive_polarity: Avg. polarity of positive words
+ min_positive_polarity: Min. polarity of positive words
+ avg_negative_polarity: Avg. polarity of negative words
+ max_negative_polarity: Max. polarity of negative words
+ title_subjectivity: Title subjectivity

The purpose of our analysis is to predict the number of shares in social networks (popularity). In this project, we produce some basic summary statistics and plots about the training data, and fit a linear regression model and an ensemble tree-based model.


# Data

Use a relative path to import the data.

```{r}
newsData<-read_csv(file="OnlineNewsPopularity.csv",show_col_types = FALSE)
head(newsData)
```

Subset the data. If running the reports by an automated parameter driven process, the report will automatically use the parameter passed into this report. If running the report manually without a parameter, the data will subset to the 'lifestyle' news channel.

```{r}
#Read the parameter being passed in to the automated report
if (params$columnNames != "") {
  paramColumnNameType<-params$columnNames
}else{
  paramColumnNameType<-"lifestyle"
}
columnName<-paste("data_channel_is_",paramColumnNameType,sep="")
#According to dplyr help, to refer to column names stored as string, use the '.data' pronoun.
#https://dplyr.tidyverse.org/reference/filter.html
newsDataSubset <- filter(newsData,.data[[columnName]] == 1)
```

Merging the weekdays columns channels as one single column named publishing_day.

```{r}
# Merging the weekdays columns channels as one single column named publishing_day
newsDataSubset <- newsDataSubset %>%
  select(url, starts_with("weekday_is")) %>%
  pivot_longer(-url) %>%
  dplyr::filter(value > 0) %>%
  mutate(publishing_day = gsub("weekday_is_", "", name)) %>%
  left_join(newsDataSubset, by = "url") %>%
  select(-name, -starts_with("weekday_is_"))
# set the publishing_day as factor variable
newsDataSubset$publishing_day<- as.factor(newsDataSubset$publishing_day)
head(newsDataSubset)
```

Here we drop some non-preditive variables: url,value,timedelta,data_channel_is_lifestyle, data_channel_is_entertainment,data_channel_is_bus, data_channel_is_socmed ,data_channel_is_tech,data_channel_is_world columns,is_weekend. They won't contribute anything.

```{r}
newsDataSubset<-newsDataSubset%>%select(-c(1,2,4,16:21,34))
newsDataSubset
```

# Data Train/Test Split

Lets set up our Train/Test split. This will allow us to determine the model fit using a subset of data called Training, while saving the remainder of the data called Test to test our model predictions with.

```{r}
set.seed(111)
train <- sample(1:nrow(newsDataSubset),size=nrow(newsDataSubset)*0.7)
test <- dplyr::setdiff(1:nrow(newsDataSubset),train)
newsDataSubsetTrain <- newsDataSubset[train,]
newsDataSubsetTest <- newsDataSubset[test,]
```

# Summarizations

## Data structure and basic summary statistics
Start with the data structure and basic summary statistics for the 'shares' field.

```{r}
# data structure
str(newsDataSubsetTrain)
```

```{r}
# data summary
summary(newsDataSubsetTrain$shares)
```

Now lets show the Mean, Median, Variance, and Standard Deviation. Notice the Variance and Standard Deviation are both extremely high. This might be something we will have to investigate further.

```{r}
newsDataSubsetTrain %>% summarise(avg = mean(shares), med = median(shares), var = var(shares), sd = sd(shares))
```

Looking at the different columns in the dataset, there are two that stand out. Generally speaking, people probably aren't going to look at articles that don't have images or videos. Here are the summary stats for the articles grouped on the number of images in the article.

```{r}
newsDataSubsetTrain %>% group_by(num_imgs) %>%
summarise(avg = mean(shares), med = median(shares), var = var(shares), sd = sd(shares))
```

As we can see from the above table, the number of shares tend to increase as the number of images increases. Therefore, the number of images variable affects shares, and we will keep this variable.

Here are the summary stats for articles with videos.
```{r}
newsDataSubsetTrain %>% group_by(num_videos) %>%
summarise(avg = mean(shares), med = median(shares), var = var(shares), sd = sd(shares))
```

As we can see from the above table, number of shares tend to increase as the number of videos increases. Therefore, the number of videos variable affects shares, and we will keep this variable.


## Plots

A plot with the number of shares on the y-axis and number of words in the title (n_tokens_title) on the x-axis is created:

```{r}
g <- ggplot(newsDataSubsetTrain, aes(x = n_tokens_title, y = shares))
g + geom_point()+labs(title = "Plot of shares VS n_tokens_title")
```

The number of shares will vary depending on on the channel type. But there is clearly a relationship between the number of words in the title and the number of shares. Therefore, the number of words in the title affects shares, and we will keep n_tokens_title variable.


A plot with the number of shares on the y-axis and publishing day (publishing_day) on the x-axis is created:

```{r}
g <- ggplot(newsDataSubsetTrain, aes(x = publishing_day, y = shares))
g + geom_point()+labs(title = "Plot of shares VS publishing_day")
```


Looking at the plot, some of the days will have a higher number of shares and some of the days will have a lower number of shares. The days with the higher shares will vary depending on the channel. For example, it makes sense that some of the business related channels have a higher share rate during the work week than the weekend. Therefore, the publishing_day affects shares, and we will keep publishing_day.

A plot with the number of shares on the y-axis and rate of positive words (rate_positive_words) on the x-axis is created:

```{r}
g <- ggplot(newsDataSubsetTrain, aes(x = rate_positive_words, y = shares))
g + geom_point()+labs(title = "Plot of shares VS rate_positive_words")
```

Looking across the plots for each of the channels, there is a correlation between using positive words and a higher share number. Therefore, the variable rate_positive_words effects shares, and we will keep this variable.

A plot with the number of shares on the y-axis and number of words in the content (n_tokens_content) on the x-axis is created:

```{r}
g <- ggplot(newsDataSubsetTrain, aes(x = n_tokens_content, y = shares))
g + geom_point()+labs(title = "Plot of shares VS n_tokens_content")
```

For each of the channel types, it is easy to see that the number of shares will decrease as the number of words in the article increases. For most channel types, the highest shares are with the articles that have less than 2000 words. Therefore, the variable n_tokens_content effects shares, and we will keep this variable.

A plot with the number of shares on the y-axis and average word length (average_token_length) on the x-axis is created:

```{r}
g <- ggplot(newsDataSubsetTrain, aes(x = average_token_length, y = shares))
g + geom_point()+labs(title = "Plot of shares VS average_token_length")
```

From the above plot, we can see that the most shares contain 4-6 length words.  Therefore, the variable average_token_length effects shares, and we will keep this variable.

Correlation matrix plot is generated:
```{r}
newsDataSubsetTrain1<-select(newsDataSubsetTrain,-publishing_day)
corr=cor(newsDataSubsetTrain1, method = c("spearman"))
corrplot(corr,tl.cex=0.5)
```

By the above correlation matrix plot, we can see these variables are strongly correlated:

+ title_subjectivity, abs_title_sentiment_polarity, abs_title_subjectivity, title_sentiment_polarity
+ avg_negative_polarity, min_negative_polarity
+ max_positive_polarity, avg_positive_polarity
+ global_rate_negative_words, rate_negative_words,rate_positive_words
+ global_sentiment_polarity, rate_negative_words, rate_positive_words
+ LDA_03,LDA_04
+ LDA_00,LDA_04
+ self_reference_max_shares, self_reference_avg_shares, self_reference_min_shares 
+ kw_max_avg, kw_avg_avg
+ kw_min_avg,kw_avg_avg,kw_min_max
+ kw_avg_max,kw_avg_avg,kw_max_max
+ kw_avg_min,kw_avg_max
+ kw_max_min,kw_avg_min,kw_min_min
+ kw_min_min,kw_avg_max
+ num_keywords,LDA_01
+ num_keywords,LDA_02
+ num_hrefs, num_imgs
+ n_non_stop_unique_tokens, num_imgs
+ n_non_stop_words, n_non_stop_unique_tokens
+ n_unique_tokens,n_non_stop_unique_tokens
+ n_unique_tokens, n_non_stop_words, n_tokens_content
+ n_tokens_content, n_non_stop_unique_tokens
+ n_tokens_content, num_hrefs

These are strongly correlated which makes us to assume that these features are so linearly dependent that any one of the strong correlated feature can be used and excluding the other features with high correlation.


## Feature selection

Let's do feature selection:
  
```{r}
newsDataSubsetTrain2<-select(newsDataSubsetTrain,-abs_title_sentiment_polarity, -abs_title_subjectivity, -title_sentiment_polarity,-min_negative_polarity,-max_positive_polarity,-rate_negative_words,-global_rate_negative_words,-global_sentiment_polarity,-LDA_03,-LDA_00,-self_reference_max_shares,-self_reference_min_shares,-kw_max_avg,-kw_min_avg,-kw_min_max,-kw_avg_max,-kw_max_max,-kw_max_min,-kw_min_min,-LDA_01,-LDA_02,-num_hrefs,-n_non_stop_unique_tokens,-n_unique_tokens,-n_non_stop_words)
newsDataSubsetTest2<-select(newsDataSubsetTrain,-abs_title_sentiment_polarity, -abs_title_subjectivity, -title_sentiment_polarity,-min_negative_polarity,-max_positive_polarity,-rate_negative_words,-global_rate_negative_words,-global_sentiment_polarity,-LDA_03,-LDA_00,-self_reference_max_shares,-self_reference_min_shares,-kw_max_avg,-kw_min_avg,-kw_min_max,-kw_avg_max,-kw_max_max,-kw_max_min,-kw_min_min,-LDA_01,-LDA_02,-num_hrefs,-n_non_stop_unique_tokens,-n_unique_tokens,-n_non_stop_words)
newsDataSubsetTrain2
```


# Modeling

## Linear Regression Model

A Linear Regression Model is the first model type we will look at. These models are an intuitive way to investigate the linear relation between multiple variables. These models make the estimation procedure simple and easy to understand. Linear Regression models can come in all different shapes and sizes and can be used to model more than just a straight linear relationship. Regression models can be modified with interactive and or higher order terms that will conform to a more complex relationship.

For the first linear model example, we can try a model using just the "num_imgs" and "num_videos" as our predictors. 

```{r}
set.seed(111)
#Fit a  multiple linear regression model using just the "num_imgs" and "num_videos" as our predictors. 
mlrFit <- train(shares ~ num_imgs + num_videos, 
                data = newsDataSubsetTrain2, 
                method="lm",
                trControl=trainControl(method="cv",number=5))
mlrFit
```

Next we can try a linear model using all of the fields as a predictor variables.

```{r}
#Fit a  multiple linear regression model using all of the fields as a predictor variables.
set.seed(111)
mlrAllFit <- train(shares ~ ., 
                data = newsDataSubsetTrain2, 
                method="lm",
                trControl=trainControl(method="cv",number=5))
mlrAllFit
```

Try a model using just the num_imgs + num_videos + kw_avg_avg + num_imgs*kw_avg_avg as our predictors. 

```{r}
set.seed(111)
#Fit a  multiple linear regression model with num_imgs + num_videos + kw_avg_avg + num_imgs*kw_avg_avg. 
mlrInteractionFit <- train(shares ~ num_imgs + num_videos + kw_avg_avg + num_imgs*kw_avg_avg, 
                data = newsDataSubsetTrain2, 
                method="lm",
                trControl=trainControl(method="cv",number=5))
mlrInteractionFit
```


## Random Forest Model

The Random Forest Model is an example of an ensemble based model. Instead of traditional decision trees, ensemble methods average across the tree. This will greatly increase our prediction power, but it will come at the expense of the easy interpretation from traditional decision trees. The Random Forest based model will not use all available predictors. Instead it will take a random subset of the predictors for each tree fit and calculate the model fit for that subset. It will repeat the process a pre-determined number of times and automatically pick the best predictors for the model. This will end up creating a reduction in the overall model variance.

```{r}
set.seed(111)
randomForestFit <- train(shares ~ ., 
                         data = newsDataSubsetTrain2, 
                         method="rf",
                         preProcess=c("center","scale"),
                         trControl=trainControl(method="cv",number=5),
                         tuneGrid=data.frame(mtry=ncol(newsDataSubsetTrain)/3))
randomForestFit
```


## Boosted Tree Model 

Boosted Regression Tree (BRT) models are a combination of two techniques: decision tree algorithms and boosting methods. It repeatedly fits many decision trees to improve the accuracy of the model. 

Boosted Regression Tree uses the boosting method in which the input data are weighted in subsequent trees. The weights are applied in such a way that data that was poorly modelled by previous trees has a higher probability of being selected in the new tree. This means that after the first tree is fitted the model will take into account the error in the prediction of that tree to fit the next tree, and so on. By taking into account the fit of previous trees that are built, the model continuously tries to improve its accuracy. This sequential approach is unique to boosting. 

```{r}
set.seed(111)
BoostedTreeFit <- train(shares ~ ., 
                         data = newsDataSubsetTrain2,
                         distribution = "gaussian",
                         method="gbm",
                         trControl=trainControl(method="cv",number=5),
                         verbose = FALSE)
BoostedTreeFit
```

# Comparison

All the models are compared by RMSE on the test set

```{r}
set.seed(111)
#compute RMSE of MlrFit
mlrFitPred <- predict(mlrFit, newdata = newsDataSubsetTest2)
MlrFit<-postResample(mlrFitPred, newsDataSubsetTest2$shares)
MlrFit.RMSE<-MlrFit[1]
#compute RMSE of MlrAllFit
MlrAllFitPred <- predict(mlrAllFit, newdata = newsDataSubsetTest2)
MlrAllFit<-postResample(MlrAllFitPred, newsDataSubsetTest2$shares)
MlrAllFit.RMSE<-MlrAllFit[1]
#compute RMSE of MlrInterFit
mlrInteractionFitPred <- predict(mlrInteractionFit, newdata = newsDataSubsetTest2)
MlrInterFit<-postResample(mlrInteractionFitPred, newsDataSubsetTest2$shares)
MlrInterFit.RMSE<-MlrInterFit[1]
#compute RMSE of RandomForest
ForestPred <- predict(randomForestFit, newdata = newsDataSubsetTest2)
RandomForest<-postResample(ForestPred, newsDataSubsetTest2$shares)
RandomForest.RMSE<-RandomForest[1]
#compute RMSE of BoostedTree
BoostPred <- predict(BoostedTreeFit, newdata = newsDataSubsetTest2)
BoostedTree<-postResample(BoostPred, newsDataSubsetTest2$shares)
BoostedTree.RMSE<-BoostedTree[1]
#Compare Root MSE values
c(MlrFit=MlrFit.RMSE,MlrAllFit=MlrAllFit.RMSE,MlrInterFit=MlrInterFit.RMSE,RandomForest=RandomForest.RMSE,BoostedTree=BoostedTree.RMSE)
```

From the above compare, we can see the smallest RMSE is 5403.120 which belong to RandomForest. Therefore, we will choose the Random Forest Model.


# Automation

Below is a chuck of code that can be used to automate the reports. In order to automate this project, the first thing we do is build a set of parameters. These parameters match up with the column names from the full news dataset. The program with read the parameter and subset the data down to only values with the specified news channel name that is in the parameter. 

To automate the project for all of the different news channels, simply execute the code chunk below directly to the console. Separate .md files will then be created for each news channel type.

```automate
#Add column names
columnNames <- data.frame("lifestyle","entertainment","bus","socmed","tech","world")
#Create filenames
output_file<-paste0(columnNames,".md")
#create a list for each column name
params = lapply(columnNames, FUN = function(x){list(columnNames = x)})
#put into a data frame
reports<-tibble(output_file,params)
#Render Code
apply(reports, MARGIN=1,FUN=function(x)
  {
    rmarkdown::render(input="Project2.Rmd",
    output_format="github_document",
    output_file=x[[1]],
    params=x[[2]],
    output_options = list(html_preview= FALSE,toc=TRUE,toc_depth=2,toc_float=TRUE)
    )
  }
)
```